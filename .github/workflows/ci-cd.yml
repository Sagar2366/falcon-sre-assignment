name: CI/CD Pipeline

on:
  push:
    branches: [main, develop, feature/*]
  pull_request:
    branches: [main, develop]

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY: crowdstrike-falcon-sre-app

jobs:
  # Build and Test
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
    
    - name: Run security scans
      run: |
        # Trivy vulnerability scan
        trivy image ${{ steps.build-image.outputs.image }}
        
        # Docker Scout
        docker scout cves ${{ steps.build-image.outputs.image }}
    
    - name: Test application
      run: |
        # Run container tests
        docker run --rm ${{ steps.build-image.outputs.image }} npm test || echo "No tests configured"
        
        # Health check
        docker run --rm -d --name test-app ${{ steps.build-image.outputs.image }}
        sleep 10
        docker exec test-app curl -f http://localhost:8080/health || echo "Health check failed"
        docker stop test-app

  # Deploy to Development
  deploy-dev:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    environment: development
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update ArgoCD Application for Dev
      run: |
        # Update the image tag in the Helm values
        sed -i "s|imageTag:.*|imageTag: ${{ github.sha }}|g" kubernetes/helm-charts/app/values-dev.yaml
        
        # Commit and push changes
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add kubernetes/helm-charts/app/values-dev.yaml
        git commit -m "Update dev image to ${{ github.sha }}" || echo "No changes to commit"
        git push
    
    - name: Wait for ArgoCD sync
      run: |
        # Wait for ArgoCD to sync the application
        kubectl config set-cluster dev --server=${{ secrets.DEV_CLUSTER_ENDPOINT }}
        kubectl config set-credentials dev --token=${{ secrets.DEV_CLUSTER_TOKEN }}
        kubectl config set-context dev --cluster=dev --user=dev
        kubectl config use-context dev
        
        # Wait for ArgoCD application to be healthy
        kubectl wait --for=condition=healthy application/sample-app -n argocd --timeout=300s

  # Deploy to Staging
  deploy-staging:
    needs: [build-and-test, deploy-dev]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update ArgoCD Application for Staging
      run: |
        # Update the image tag in the Helm values
        sed -i "s|imageTag:.*|imageTag: ${{ github.sha }}|g" kubernetes/helm-charts/app/values-staging.yaml
        
        # Commit and push changes
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add kubernetes/helm-charts/app/values-staging.yaml
        git commit -m "Update staging image to ${{ github.sha }}" || echo "No changes to commit"
        git push
    
    - name: Wait for ArgoCD sync
      run: |
        # Wait for ArgoCD to sync the application
        kubectl config set-cluster staging --server=${{ secrets.STAGING_CLUSTER_ENDPOINT }}
        kubectl config set-credentials staging --token=${{ secrets.STAGING_CLUSTER_TOKEN }}
        kubectl config set-context staging --cluster=staging --user=staging
        kubectl config use-context staging
        
        # Wait for ArgoCD application to be healthy
        kubectl wait --for=condition=healthy application/sample-app -n argocd --timeout=300s
    
    - name: Run staging tests
      run: |
        # Run integration tests against staging
        curl -f ${{ secrets.STAGING_APP_URL }}/health || echo "Staging health check failed"

  # Deploy to Production
  deploy-production:
    needs: [build-and-test, deploy-staging]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Update ArgoCD Application for Production
      run: |
        # Update the image tag in the Helm values
        sed -i "s|imageTag:.*|imageTag: ${{ github.sha }}|g" kubernetes/helm-charts/app/values-production.yaml
        
        # Commit and push changes
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add kubernetes/helm-charts/app/values-production.yaml
        git commit -m "Update production image to ${{ github.sha }}" || echo "No changes to commit"
        git push
    
    - name: Wait for ArgoCD sync
      run: |
        # Wait for ArgoCD to sync the application
        kubectl config set-cluster production --server=${{ secrets.PROD_CLUSTER_ENDPOINT }}
        kubectl config set-credentials production --token=${{ secrets.PROD_CLUSTER_TOKEN }}
        kubectl config set-context production --cluster=production --user=production
        kubectl config use-context production
        
        # Wait for ArgoCD application to be healthy
        kubectl wait --for=condition=healthy application/sample-app -n argocd --timeout=300s
    
    - name: Run production tests
      run: |
        # Run smoke tests against production
        curl -f ${{ secrets.PROD_APP_URL }}/health || echo "Production health check failed"
    
    - name: Notify deployment success
      run: |
        # Send notification to Slack/PagerDuty
        echo "Production deployment successful: ${{ github.sha }}"

  # Rollback on failure
  rollback:
    needs: [deploy-production]
    runs-on: ubuntu-latest
    if: failure()
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Rollback to previous version
      run: |
        # Rollback logic here
        echo "Rolling back deployment..."
        
    - name: Notify rollback
      run: |
        # Send rollback notification
        echo "Deployment rolled back due to failure" 